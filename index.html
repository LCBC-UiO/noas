<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>tree test</title>
  <script src="d3.v6.min.js"></script>
  <style>

    .node circle {
      cursor: pointer;
      fill: #fff;
      stroke: steelblue;
      stroke-width: 3px;
    }
    

    .node text {
      font-family: sans-serif;
      font-size: 12px;
    }
    /* .node-label {
    } */
    .node text.node-caption {
      font-size: 10px;
      font-style: italic;
    }
    
    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }

    html, body {
      margin: 0;
      height: 100%;
    }

    body {
      display: flex;
    }

    .box {
      display: flex;
      flex-flow: column;
      height: 100%;
    };

    .container {
      flex: 1 1 auto;
    }

   
    svg {
      cursor: grab;
    }
    
  </style>
</head>
<body>
  <div class="box"><div id="body" class="container"></div></div>
  <script src="dbmeta_s2c.js"></script>
  <script>
    
    

    function dbmeta_to_tree(m) {
      function _getPath(table) {
        if (table.id == "core") {
          return [];
        }

        let path = ["non_core"];
        if (table.category) {
          path.push(table.category);
        }
        return path;
      }
      function _insertTableNode(tree, path, node) {
        // insert category?
        if (path.length) {
          const category = path[0];
          tnext = tree.children.filter(e => e.id == category)[0];
          // create new category;
          if (tnext == undefined) {
            tnext = {
              id: category,
              children: [],
            }
            tree.children.push(tnext);
          }
          _insertTableNode(tnext, path.slice(1), node);
          return;
        }
        // create table node?
        delete Object.assign(node, {["children"]: node["columns"]})["columns"];
        tree.children.push(node);
      }

      let tree = {
        id: "noas_data",
        children: []
      };
      m.data.tables.forEach(e => {
        const path = _getPath(e);
        _insertTableNode(tree, path, e);  
      });
      return(tree);
    }
    
    async function start() {

      var treeData =
        {
          "name": "Top Level",
          id: "root",
          "children": [
            { 
              "name": "Level 2: A",
              id: "sd",
              "children": [
                { "name": "Son of A", id:"sona" },
                { "name": "Daughter of A", id: "daua" }
              ]
            },
            { "name": "Level 2: B", id:"lvl2b" }
          ]
        };
        //console.log(dbmeta_to_tree(dbmeta_s2c));
        treeData = dbmeta_to_tree(dbmeta_s2c);


      // Set the dimensions and margins of the diagram
      var margin = {top: 20, right: 390, bottom: 30, left: 90};
      var width = document.getElementById("body").width;
      console.log(width);
      var height = document.getElementById("body").height;
      console.log(height);
          // width = 960 - margin.left - margin.right,
          // height = 900 - margin.top - margin.bottom;

      // append the svg object to the body of the page
      // appends a 'group' element to 'svg'
      // moves the 'group' element to the top left margin
      var svg = d3.select("body").append("svg")
          // .attr("width", width + margin.right + margin.left)
          // .attr("height", height + margin.top + margin.bottom)
          .attr("width", "100%")
          .attr("height", height)
        .append("g")
          .attr("transform", "translate("
                + margin.left + "," + margin.top + ")");

      var i = 0,
          duration = 750,
          root;

      // declares a tree layout and assigns the size
      var treemap = d3.tree().nodeSize([30,30]);

      // Assigns parent, children, height, depth
      root = d3.hierarchy(treeData, function(d) { return d.children; });
      root.x0 = height / 2;
      root.y0 = 0;

      // Collapse after the second level
      root.children[0].children.forEach(collapse);
      root.children[1].children.forEach(collapse);
      //collapse(root);

      update(root);

      let g_transform =  d3.zoomTransform(d3.select("g"));
      var hmax = d3.max(d3.selectAll("g.node").data(), e => e.x);
      var hmin = d3.min(d3.selectAll("g.node").data(), e => e.x);
      var wmax = d3.max(d3.selectAll("g.node").data(), e => e.y);
      var wmin = d3.min(d3.selectAll("g.node").data(), e => e.y);

      g_transform.x = margin.left - wmin;
      g_transform.y = margin.top  - hmin;
      d3.select("body")
      .select("svg")
        .select("g")
        .transition()
        .duration(duration)
          .attr("transform", g_transform)
      ;

      // Collapse the node and all it's children
      function collapse(d) {
        if(d.children) {
          d._children = d.children
          d._children.forEach(collapse)
          d.children = null
        }
      }
      
      d3.select("svg").call(d3.drag()
        .on("start", drag_start)
        .on("drag", drag_drag)
        .on("end", drag_end)
      );   

      function drag_start() {
        //g.attr("cursor", "grabbing");
      }
      function drag_drag(event, d) {
        d = event.sourceEvent.originalTarget;
        g_transform.x += event.dx;
        g_transform.y += event.dy;
        d3.select("g").attr("transform", g_transform);
      }
      function drag_end() {
      }

      d3.select("svg")
        .call(
          d3.zoom()
            .extent([[0, 0], [400, 400]])
            .scaleExtent([1/4, 8])
            .on("zoom", zoomed)
        ).on("dblclick.zoom", null);
      
      function zoomed({transform}) {
        g_transform = transform;
        d3.select("g").attr("transform", g_transform);
      }

      function update(source) {

        // Assigns the x and y position for the nodes
        var treeData = treemap(root);

        // Compute the new tree layout.
        var nodes = treeData.descendants(),
            links = treeData.descendants().slice(1);

        // Normalize for fixed-depth.
       nodes.forEach(function(d){ d.y = d.depth * 240});

        // ****************** Nodes section ***************************

        // Update the nodes...
        var node = svg.selectAll('g.node')
            .data(nodes, function(d) {return d.id || (d.id = ++i); });

        // Enter any new modes at the parent's previous position.
        var nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr("transform", function(d) {
              return "translate(" + source.y0 + "," + source.x0 + ")";
          })
          .on('click', click);

        // Add Circle for the nodes
        nodeEnter.append('circle')
            .attr('class', 'node')
            .attr('r', 1e-6)
            .style("fill", function(d) {
                return d._children ? "lightsteelblue" : "#fff";
            });
        
       function isTable (t) { return t.n !== undefined;}
       function isColumn (t) { return t.title !== undefined && t.columns === undefined;}
        // Add labels for the nodes
        nodeEnter.append('text')
            .call((e) => {
              e.nodes().forEach(n => {
                const nd = n.__data__.data;
                if (isTable(nd)) {
                  n.setAttribute("text-anchor", "end");
                  n.setAttribute("font-weight", "bold");
                  n.setAttribute("dy", -4);
                  n.setAttribute("x", -13);
                  n.textContent = nd.title;
                  return;
                }
                if (isColumn(nd)) {
                  n.setAttribute("text-anchor", "start");
                  n.setAttribute("dy", ".35em");
                  n.setAttribute("x", 13);
                  n.textContent = nd.title;
                  return;
                }
                n.setAttribute("text-anchor", "end");
                n.setAttribute("dy", ".35em");
                n.setAttribute("x", -13);
                n.textContent = nd.id;
              });
            });
        nodeEnter.append('text')
            .call((e) => {
              e.nodes().forEach(n => {
                const nd = n.__data__.data;
                if (isTable(nd)) {
                  n.setAttribute("text-anchor", "end");
                  n.setAttribute("dy", 9);
                  n.setAttribute("class", "node-caption");
                  n.setAttribute("x", -13);
                  n.textContent = `${nd.id}; n=${nd.n}`;
                }
              });
            });

            // .attr("dy", ".35em")
            // .attr("x", function(d) {
            //     return d.children || d._children ? -13 : 13;
            // })
            // // .attr("text-anchor", function(d) {
            // //     return d.children || d._children ? "end" : "start";
            // // })
            // .text(function(d) { 
            //   if (d.data.title) return d.data.title;
            //   return d.data.id; 
            // });

        // UPDATE
        var nodeUpdate = nodeEnter.merge(node);

        // Transition to the proper position for the node
        nodeUpdate.transition()
          .duration(duration)
          .attr("transform", function(d) { 
              return "translate(" + d.y + "," + d.x + ")";
          });

        // Update the node attributes and style
        nodeUpdate.select('circle.node')
          .attr('r', 10)
          .style("fill", function(d) {
              return d._children ? "lightsteelblue" : "#fff";
          })
          .attr('cursor', 'pointer');


        // Remove any exiting nodes
        var nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", function(d) {
                return "translate(" + source.y + "," + source.x + ")";
            })
            .remove();

        // On exit reduce the node circles size to 0
        nodeExit.select('circle')
          .attr('r', 1e-6);

        // On exit reduce the opacity of text labels
        nodeExit.selectAll('text')
          .style('fill-opacity', 1e-6);

        // ****************** links section ***************************

        // Update the links...
        var link = svg.selectAll('path.link')
            .data(links, function(d) { return d.id; });

        // Enter any new links at the parent's previous position.
        var linkEnter = link.enter().insert('path', "g")
            .attr("class", "link")
            .attr('d', function(d){
              var o = {x: source.x0, y: source.y0}
              return diagonal(o, o)
            });

        // UPDATE
        var linkUpdate = linkEnter.merge(link);

        // Transition back to the parent element position
        linkUpdate.transition()
            .duration(duration)
            .attr('d', function(d){ return diagonal(d, d.parent) });

        // Remove any exiting links
        var linkExit = link.exit().transition()
            .duration(duration)
            .attr('d', function(d) {
              var o = {x: source.x, y: source.y}
              return diagonal(o, o)
            })
            .remove();

        // Store the old positions for transition.
        nodes.forEach(function(d){
          d.x0 = d.x;
          d.y0 = d.y;
        });

        // Creates a curved (diagonal) path from parent to the child nodes
        function diagonal(s, d) {

          path = `M ${s.y} ${s.x}
                  C ${(s.y + d.y) / 2} ${s.x},
                    ${(s.y + d.y) / 2} ${d.x},
                    ${d.y} ${d.x}`

          return path
        }

        // Toggle children on click.
        function click(event, d) {
          if (d.children) {
              d._children = d.children;
              d.children = null;
            } else {
              d.children = d._children;
              d._children = null;
            }
          update(d);
          event.stopPropagation();
        }
      }
      // var hmax = d3.max(d3.selectAll("g.node").data(), e => e.x);
      // var hmin = d3.min(d3.selectAll("g.node").data(), e => e.x);
      // var wmax = d3.max(d3.selectAll("g.node").data(), e => e.y);
      // var wmin = d3.min(d3.selectAll("g.node").data(), e => e.y);
      // d3.select("body")
      // .select("svg")
      //     .attr("width", wmax - wmin + margin.right + margin.left)
      //     .attr("height", hmax - hmin + margin.top + margin.bottom)
      //   .select("g")
      //   .transition()
      //   .duration(duration)
      //     .attr("transform", `translate(${margin.left},${margin.top - hmin})`)
      // ;

    }
    start();

  //   window.setTimeout(function() {
  //     d3.selectAll(".node");
  //     console.log(d3.selectAll(".node").size());
  //     var max = 600;
  //   //set the max of the group
  //   d3.select("svg").attr("height", max + 100)
  //   console.log(max)
  // }, 800)

  </script>
</body>
</html>