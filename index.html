<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>tree test</title>
  <script src="d3.v6.min.js"></script>
  <style>

    .node circle {
      cursor: pointer;
      fill: #fff;
      stroke: steelblue;
      stroke-width: 3px;
    }
    

    .node text {
      font-family: sans-serif;
      font-size: 12px;
    }
    /* .node-label {
    } */
    .node text.node-caption {
      font-size: 11px;
      font-style: italic;
    }
    
    .link {
      fill: none;
      stroke: #ddd;
      stroke-width: 2px;
    }

    html, body {
      margin: 0;
      height: 100%;
    }

    body {
      display: flex;
    }

    #treebox {
      display: flex;
      flex-flow: column;
      height: 100%;
      width: 100%;
    };

    #tree {
      flex: 1 1 auto;
    }

   
    svg {
      cursor: grab;
    }
    
  </style>
</head>
<body>
  <div id="treebox"><div id="tree"></div></div>
  <script src="dbmeta_all.js"></script>
  <script>
    
    

    function dbmeta_to_tree(m) {
      function _getPath(table) {
        if (table.id == "core") {
          return [];
        }

        let path = ["non_core"];
        if (table.category) {
          path.push(table.category);
        }
        return path;
      }
      function _insertTableNode(tree, path, node) {
        // insert category?
        if (path.length) {
          const category = path[0];
          tnext = tree.children.filter(e => e.id == category)[0];
          // create new category;
          if (tnext == undefined) {
            tnext = {
              id: category,
              children: [],
            }
            tree.children.push(tnext);
          }
          _insertTableNode(tnext, path.slice(1), node);
          return;
        }
        // create table node?
        delete Object.assign(node, {["children"]: node["columns"]})["columns"];
        tree.children.push(node);
      }

      let tree = {
        id: "noas_data",
        children: []
      };
      m.data.tables.forEach(e => {
        const path = _getPath(e);
        _insertTableNode(tree, path, e);  
      });
      return(tree);
    }
    
    async function start() {

      var treeData =
        {
          "name": "Top Level",
          id: "root",
          "children": [
            { 
              "name": "Level 2: A",
              id: "sd",
              "children": [
                { "name": "Son of A", id:"sona" },
                { "name": "Daughter of A", id: "daua" }
              ]
            },
            { "name": "Level 2: B", id:"lvl2b" }
          ]
        };
        //console.log(dbmeta_to_tree(dbmeta_s2c));
        treeData = dbmeta_to_tree(dbmeta_all);


      // Set the dimensions and margins of the diagram
      var margin = {top: 20, right: 390, bottom: 30, left: 90};
      var width = document.getElementById("treebox").width;
      var height = document.getElementById("treebox").offsetHeight;

      // console.log(height);

      // append the svg object to the body of the page
      // appends a 'group' element to 'svg'
      // moves the 'group' element to the top left margin
      var svg = d3.select("#tree").append("svg")
          // .attr("width", width + margin.right + margin.left)
          // .attr("height", height + margin.top + margin.bottom)
          .attr("width", "100%")
          .attr("height", height)
        .append("g")
          .attr("transform", "translate("
                + margin.left + "," + margin.top + ")");

      var i = 0,
          duration = 750,
          root;

      // declares a tree layout and assigns the size
      var treemap = d3.tree().nodeSize([30,30]);

      // Assigns parent, children, height, depth
      root = d3.hierarchy(treeData, function(d) { return d.children; });
      root.x0 = height / 2;
      root.y0 = 0;{
      // console.log([root.x0, root.y0]);

      // Collapse after the second level
      root.children[0].children.forEach(collapse);
      root.children[1].children.forEach(collapse);}
      //collapse(root);

      update(root, null, null);
      
      // fit to page
      {
        let g_transform =  d3.zoomTransform(d3.select("g"));
        var hmax = d3.max(d3.selectAll("g.node").data(), e => e.x);
        var hmin = d3.min(d3.selectAll("g.node").data(), e => e.x);
        var wmax = d3.max(d3.selectAll("g.node").data(), e => e.y);
        var wmin = d3.min(d3.selectAll("g.node").data(), e => e.y);

        g_transform.x = margin.left - wmin;
        g_transform.y = margin.top  - hmin;
        d3.select("body")
        .select("svg")
          .select("g")
          .transition()
          .duration(duration)
            .attr("transform", g_transform)
        ;
      }

      // Collapse the node and all it's children
      function collapse(d) {
        if(d.children) {
          d._children = d.children
          d._children.forEach(collapse)
          d.children = null
        }
      }
      
      d3.select("svg").call(d3.drag()
        .on("start", drag_start)
        .on("drag", drag_drag)
        .on("end", drag_end)
      );   

      function drag_start() {
        //g.attr("cursor", "grabbing");
        g_transform = d3.zoomTransform(d3.select('g').node());
      }
      function drag_drag(event, d) {
        //d = event.sourceEvent.originalTarget;
        g_transform.x += event.dx;
        g_transform.y += event.dy;
        d3.select("body").select("svg").select("g").attr("transform", g_transform);
      }
      function drag_end() {
      }

      d3.select("svg")
        .call(
          d3.zoom()
            .extent([[0, 0], [400, 400]])
            .scaleExtent([1/4, 8])
            .on("zoom", zoomed)
        ).on("dblclick.zoom", null);
      
      function zoomed({transform}) {
        g_transform = transform;
        d3.select("g").attr("transform", g_transform);
      }

      function update(source, update_type, event) {
        const srcpos_org = {x: source.x0, y: source.y0};

        // Assigns the x and y position for the nodes
        var treeData = treemap(root);

        // Compute the new tree layout.
        var nodes = treeData.descendants(),
            links = treeData.descendants().slice(1);

        // var l_transform = {x: 0, y: 0};
        // if (update_type) {
        //   // console.log(update_type);
        //   // console.log(d3.transform(d3.select('g').attr("transform")));
        //   l_transform = d3.zoomTransform(d3.select('g').node());
          
        //   const c_width  = document.querySelector('body').offsetWidth;
        //   const c_height = document.querySelector('body').offsetHeight;
        //   console.log(`x: ${l_transform.x} += ${(c_width)} / 2 - ${event.x}  => ${l_transform.x + (c_width/2)  - event.x}`);
        //   console.log(`y: ${l_transform.y} += ${(c_height)} / 2 - ${event.y} => ${l_transform.y + (c_height/2) - event.y}`);
        //   l_transform.x +=  (c_width/2)  - event.x;
        //   l_transform.y +=  (c_height/2) - event.y;
        // }


        // Normalize for fixed-depth.
       nodes.forEach(function(d){ d.y = d.depth * 240});

        // ****************** Nodes section ***************************

        // Update the nodes...
        var node = svg.selectAll('g.node')
            .data(nodes, function(d) {return d.id || (d.id = ++i); });

        // Enter any new modes at the parent's previous position.
        var nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr("transform", function(d) {
              return "translate(" + source.y0 + "," + source.x0 + ")";
          })
          .on('click', click);

        // Add Circle for the nodes
        nodeEnter.append('circle')
            .attr('class', 'node')
            .attr('r', 1e-6)
            .style("fill", function(d) {
                return d._children ? "lightsteelblue" : "#fff";
            });
        
       function isTable (t) { return t.n !== undefined;}
       function isColumn (t) { return t.title !== undefined && t.columns === undefined;}
        
        node.select('text')
          .merge(nodeEnter.append("text"))
            .text(function (d) {
              if (isTable(d.data)) {
                return `${d.data.id}; n=${d.data.n}`;
                //return `${d.data.title} (${d.data.id}; n=${d.data.n})`;
              }
              return d.data.title ?? d.data.id; 
            })
            .attr("text-anchor", "middle")
            .transition().duration(duration)
              .attr("x", function(d) {
                return (this.getBBox().width/2 + 13) * (d.children ? -1 : 1);
              });
            ;
        // UPDATE
        var nodeUpdate = nodeEnter.merge(node);

        // Transition to the proper position for the node
        nodeUpdate.transition()
          .duration(duration)
          .attr("transform", function(d) { 
              return "translate(" + d.y + "," + d.x + ")";
          });

        // Update the node attributes and style
        nodeUpdate.select('circle.node')
          .attr('r', 10)
          .style("fill", function(d) {
              return d._children ? "lightsteelblue" : "#fff";
          })
          .attr('cursor', 'pointer');


        // Remove any exiting nodes
        var nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", function(d) {
                return "translate(" + source.y + "," + source.x + ")";
            })
            .remove();

        // On exit reduce the node circles size to 0
        nodeExit.select('circle')
          .attr('r', 1e-6);

        // On exit reduce the opacity of text labels
        nodeExit.selectAll('text')
          .style('fill-opacity', 1e-6);

        // ****************** links section ***************************

        // Update the links...
        var link = svg.selectAll('path.link')
            .data(links, function(d) { return d.id; });

        // Enter any new links at the parent's previous position.
        var linkEnter = link.enter().insert('path', "g")
            .attr("class", "link")
            .attr('d', function(d){
              var o = {x: source.x0, y: source.y0}
              return diagonal(o, o)
            });

        // UPDATE
        var linkUpdate = linkEnter.merge(link);

        // Transition back to the parent element position
        linkUpdate.transition()
            .duration(duration)
            .attr('d', function(d){ return diagonal(d, d.parent) });

        // Remove any exiting links
        var linkExit = link.exit().transition()
            .duration(duration)
            .attr('d', function(d) {
              var o = {x: source.x, y: source.y}
              return diagonal(o, o)
            })
            .remove();

        // Store the old positions for transition.
        nodes.forEach(function(d){
          d.x0 = d.x;
          d.y0 = d.y;
        });

        // Creates a curved (diagonal) path from parent to the child nodes
        function diagonal(s, d) {

          path = `M ${s.y} ${s.x}
                  C ${(s.y + d.y) / 2} ${s.x},
                    ${(s.y + d.y) / 2} ${d.x},
                    ${d.y} ${d.x}`

          return path
        }

        // Toggle children on click.
        function click(event, d) {
          if (d.children) {
              d._children = d.children;
              d.children = null;
              update(d, "close", event);
            } else {
              d.children = d._children;
              d._children = null;
              update(d, "open", event);
            }
          event.stopPropagation();
        }

        
        // d3.select("body")
        //   .select("svg")
        //   .select("g")
        //   .transition()
        //   .duration(duration)
        //     .attr("transform", `translate(${l_transform.x},${l_transform.y})`);
        // d3.select("g").transition().on("end", () => {
        //   console.log("transition end");
        //   if (update_type) {
        //     // console.log(update_type);
        //     // console.log(d3.transform(d3.select('g').attr("transform")));
        //     l_transform = d3.zoomTransform(d3.select('g').node());
            
        //     const c_width  = document.querySelector('body').offsetWidth;
        //     const c_height = document.querySelector('body').offsetHeight;
        //     console.log(`x: ${l_transform.x} += ${(c_width)} / 2 - ${event.x}  => ${l_transform.x + (c_width/2)  - event.x}`);
        //     console.log(`y: ${l_transform.y} += ${(c_height)} / 2 - ${event.y} => ${l_transform.y + (c_height/2) - event.y}`);
        //     l_transform.x +=  (c_width/2)  - event.x;
        //     l_transform.y +=  (c_height/2) - event.y;
        //     console.log(source);
        //   }
        // });
          // console.log(source);
          // console.log(`sx ${source.x} sx0 ${source.x0} sy ${source.y} sy0 ${source.y0}`);
      }
      // var hmax = d3.max(d3.selectAll("g.node").data(), e => e.x);
      // var hmin = d3.min(d3.selectAll("g.node").data(), e => e.x);
      // var wmax = d3.max(d3.selectAll("g.node").data(), e => e.y);
      // var wmin = d3.min(d3.selectAll("g.node").data(), e => e.y);
      // d3.select("body")
      // .select("svg")
      //     .attr("width", wmax - wmin + margin.right + margin.left)
      //     .attr("height", hmax - hmin + margin.top + margin.bottom)
      //   .select("g")
      //   .transition()
      //   .duration(duration)
      //     .attr("transform", `translate(${margin.left},${margin.top - hmin})`)
      // ;

    }
    start();

  //   window.setTimeout(function() {
  //     d3.selectAll(".node");
  //     console.log(d3.selectAll(".node").size());
  //     var max = 600;
  //   //set the max of the group
  //   d3.select("svg").attr("height", max + 100)
  //   console.log(max)
  // }, 800)

  </script>
</body>
</html>